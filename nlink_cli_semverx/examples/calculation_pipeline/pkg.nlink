# examples/calculation_pipeline/pkg.nlink
# SemVerX Project Coordination Manifest for Mathematical Calculation Pipeline

[project]
name = mathematical_calculation_pipeline
version = 1.0.0
entry_point = calculation_orchestrator
description = SemVerX demonstration: coordinated mathematical computation

[build]
pass_mode = multi                    # Multi-pass required for component coordination
experimental_mode = true             # Allow experimental component integration
semverx_enabled = true               # Enable SemVerX range state processing

[semverx]
# Core SemVerX coordination configuration
range_state = stable                 # Project operates in stable range
registry_mode = centralized          # Single registry coordination
validation_level = strict            # Enforce compatibility validation

# Shared artifact coordination paths
shared_registry_path = ./shared_orchestration/calculation_registry.nlink
compatibility_matrix_path = ./shared_orchestration/algorithm_compatibility.nlink
range_policies_path = ./shared_orchestration/precision_policies.nlink

# Hot-swapping policies for calculation components
hot_swap_enabled = true
runtime_validation = true
allow_cross_range_swap = false       # Prevent experimental → stable without validation

[calculation_pipeline]
# Domain-specific configuration for mathematical operations
precision_requirements = double
algorithm_fallback = basic_math
experimental_algorithms_allowed = true
result_validation_required = true
maximum_calculation_depth = 10

[threading]
worker_count = 4                     # Parallel calculation support
queue_depth = 64
enable_work_stealing = true

[features]
shared_artifact_coordination = true
component_compatibility_validation = true
calculation_result_caching = true
algorithm_performance_monitoring = true

---

# examples/calculation_pipeline/shared_orchestration/calculation_registry.nlink
# Shared Component Registry for Mathematical Calculation Pipeline

[shared_calculation_registry]
registry_version = 1.0.0
last_updated = 2025-06-10T18:30:00Z
total_algorithms = 2
coordination_mode = centralized

[registry_metadata]
registry_checksum = 0xABC12345
validation_timestamp = 2025-06-10T18:30:00Z
compatibility_matrix_version = 1.0.0

# Stable Range State Components
[component_basic_math]
component_name = basic_math_calculator
range_state = stable
version = 1.2.0
compatible_range = ^1.2.0
build_path = ./basic_math/build/calculator
source_path = ./basic_math/src/calculator.c

# Component capabilities and metadata
capabilities = ["add", "subtract", "multiply", "divide"]
precision_level = single
memory_footprint_kb = 64
execution_time_typical_ms = 1

# SemVerX coordination settings
hot_swap_enabled = true
runtime_validation = strict
fallback_component = none
requires_validation_with = ["experimental.*"]

# Component swappability rules
swappable_with = ["basic_math.1.1.x", "basic_math.1.3.x"]
exclusions = ["experimental.*", "legacy.*"]
upgrade_path = basic_math.1.3.0

# Experimental Range State Components  
[component_advanced_math]
component_name = advanced_math_scientific
range_state = experimental
version = 2.0.0-alpha.1
compatible_range = 2.0.0-alpha.x
build_path = ./advanced_math/build/scientific
source_path = ./advanced_math/src/scientific.c

# Enhanced capabilities for scientific computing
capabilities = ["sin", "cos", "tan", "log", "exp", "sqrt", "pow", "factorial"]
precision_level = double
memory_footprint_kb = 256
execution_time_typical_ms = 5

# Experimental component coordination
hot_swap_enabled = false            # Disabled for experimental range
runtime_validation = paranoid
fallback_component = basic_math_calculator
requires_opt_in = true
explicit_validation_required = true

# Experimental swappability (limited)
swappable_with = ["advanced_math.2.0.0-alpha.2", "advanced_math.2.0.0-beta.1"]
exclusions = ["stable.*", "legacy.*"]
migration_path = advanced_math.2.1.0-stable

---

# examples/calculation_pipeline/shared_orchestration/algorithm_compatibility.nlink
# Compatibility Matrix for Mathematical Algorithm Coordination

[compatibility_matrix]
matrix_version = 1.0.0
enforcement_mode = strict
last_validation = 2025-06-10T18:30:00Z

[matrix_metadata]
total_components = 2
total_compatibility_rules = 6
validation_checksum = 0xDEF67890

# Stable Range Compatibility Rules
[stable_range_compatibility]
basic_math.self_compatibility = always_allowed
basic_math.version_upgrade_policy = minor_versions_allowed
basic_math.hot_swap_policy = within_range_automatic

# Stable ↔ Stable interactions
basic_math.compatible_with_stable = all_stable_components
basic_math.data_exchange_format = ieee_754_double
basic_math.result_validation = checksum_verification

# Experimental Range Compatibility Rules
[experimental_range_compatibility]
advanced_math.self_compatibility = alpha_versions_only
advanced_math.version_upgrade_policy = explicit_validation_required
advanced_math.hot_swap_policy = disabled_for_safety

# Experimental ↔ Experimental interactions
advanced_math.compatible_with_experimental = same_major_version
advanced_math.data_exchange_format = extended_precision
advanced_math.result_validation = cross_verification_required

# Cross-Range Compatibility Rules
[cross_range_compatibility]
stable_to_experimental = calculation_chaining_allowed
experimental_to_stable = result_validation_mandatory
experimental_fallback_to_stable = automatic_on_failure

# Data flow validation between range states
stable_experimental_data_validation = strict_type_checking
experimental_stable_result_verification = independent_calculation
cross_range_error_handling = graceful_degradation

# Component coordination policies
[coordination_policies]
calculation_pipeline_validation = end_to_end_verification
algorithm_selection_priority = stable_preferred_fallback
experimental_algorithm_usage = explicit_opt_in_required
result_consistency_checking = cross_component_validation

---

# examples/calculation_pipeline/shared_orchestration/precision_policies.nlink
# Precision and Performance Policies for Calculation Coordination

[precision_policies]
policy_version = 1.0.0
enforcement_level = strict
performance_monitoring = enabled

[global_precision_requirements]
minimum_precision = single
preferred_precision = double
maximum_precision = extended
precision_validation = mandatory

# Range State Precision Policies
[stable_component_precision]
basic_math.required_precision = single
basic_math.result_tolerance = 1e-6
basic_math.overflow_handling = saturation
basic_math.underflow_handling = flush_to_zero

[experimental_component_precision]
advanced_math.required_precision = double
advanced_math.result_tolerance = 1e-12
advanced_math.overflow_handling = exception
advanced_math.underflow_handling = preserve_precision

# Performance Coordination Policies
[performance_policies]
maximum_calculation_time_ms = 1000
memory_usage_limit_mb = 100
cpu_usage_monitoring = enabled
algorithm_performance_profiling = detailed

# Hot-swap performance requirements
[hot_swap_performance]
swap_validation_timeout_ms = 500
fallback_activation_time_ms = 100
component_startup_time_ms = 50
memory_transition_overhead_mb = 10

# Calculation pipeline orchestration
[pipeline_orchestration]
component_selection_algorithm = performance_priority
fallback_chain_depth = 3
result_caching_policy = temporary
cross_component_optimization = enabled